<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>java:too many open files 解决办法 | 逆天改命</title><meta name=google-adsense-account content="ca-pub-7732072032123305"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=keywords content><meta name=description content="[TOC]
产生原因 Linux 中,文件是一个字节序列。这种简单但强大的定义和它的实现使得系统中的所有东西都可以用文件来表示。这里提示的打开文件过多，不仅仅是普通的文件，也包括通讯链接socket，监听端口。这个错误通常是句柄数超出系统限制。
引起的原因就是进程在某个时刻打开了超过系统限制的文件数量以及通讯链接数。
通过命令ulimit -a可以查看当前系统设置的最大句柄数是多少： $ ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 15065 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 15065 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited open files那一行就代表系统目前允许单个进程打开的最大句柄数，这里是1024。"><meta name=generator content="Hugo 0.119.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><link rel=canonical href=https://linkall.pub/blog/too-many-open-files/><meta property="og:title" content="java:too many open files 解决办法"><meta property="og:description" content="[TOC]
产生原因 Linux 中,文件是一个字节序列。这种简单但强大的定义和它的实现使得系统中的所有东西都可以用文件来表示。这里提示的打开文件过多，不仅仅是普通的文件，也包括通讯链接socket，监听端口。这个错误通常是句柄数超出系统限制。
引起的原因就是进程在某个时刻打开了超过系统限制的文件数量以及通讯链接数。
通过命令ulimit -a可以查看当前系统设置的最大句柄数是多少： $ ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 15065 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 15065 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited open files那一行就代表系统目前允许单个进程打开的最大句柄数，这里是1024。"><meta property="og:type" content="article"><meta property="og:url" content="https://linkall.pub/blog/too-many-open-files/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-06-13T10:43:22+00:00"><meta property="article:modified_time" content="2020-06-13T10:43:22+00:00"><meta itemprop=name content="java:too many open files 解决办法"><meta itemprop=description content="[TOC]
产生原因 Linux 中,文件是一个字节序列。这种简单但强大的定义和它的实现使得系统中的所有东西都可以用文件来表示。这里提示的打开文件过多，不仅仅是普通的文件，也包括通讯链接socket，监听端口。这个错误通常是句柄数超出系统限制。
引起的原因就是进程在某个时刻打开了超过系统限制的文件数量以及通讯链接数。
通过命令ulimit -a可以查看当前系统设置的最大句柄数是多少： $ ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 15065 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 15065 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited open files那一行就代表系统目前允许单个进程打开的最大句柄数，这里是1024。"><meta itemprop=datePublished content="2020-06-13T10:43:22+00:00"><meta itemprop=dateModified content="2020-06-13T10:43:22+00:00"><meta itemprop=wordCount content="248"><meta itemprop=keywords content="tools,java,debug,"><meta name=twitter:card content="summary"><meta name=twitter:title content="java:too many open files 解决办法"><meta name=twitter:description content="[TOC]
产生原因 Linux 中,文件是一个字节序列。这种简单但强大的定义和它的实现使得系统中的所有东西都可以用文件来表示。这里提示的打开文件过多，不仅仅是普通的文件，也包括通讯链接socket，监听端口。这个错误通常是句柄数超出系统限制。
引起的原因就是进程在某个时刻打开了超过系统限制的文件数量以及通讯链接数。
通过命令ulimit -a可以查看当前系统设置的最大句柄数是多少： $ ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 15065 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 15065 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited open files那一行就代表系统目前允许单个进程打开的最大句柄数，这里是1024。"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">逆天改命</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Blogs</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">java:too many open files 解决办法</h1><time class="f6 mv4 dib tracked" datetime=2020-06-13T10:43:22Z>June 13, 2020</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>[TOC]</p><h2 id=产生原因>产生原因</h2><p>Linux 中,文件是一个字节序列。这种简单但强大的定义和它的实现使得系统中的所有东西都可以用文件来表示。这里提示的打开文件过多，不仅仅是普通的文件，也包括通讯链接socket，监听端口。这个错误通常是句柄数超出系统限制。</p><p>引起的原因就是进程在某个时刻打开了超过系统限制的文件数量以及通讯链接数。</p><ul><li>通过命令<code>ulimit -a</code>可以查看当前系统设置的最大句柄数是多少：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ulimit -a
</span></span><span style=display:flex><span>core file size          <span style=color:#f92672>(</span>blocks, -c<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>data seg size           <span style=color:#f92672>(</span>kbytes, -d<span style=color:#f92672>)</span> unlimited
</span></span><span style=display:flex><span>scheduling priority             <span style=color:#f92672>(</span>-e<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>file size               <span style=color:#f92672>(</span>blocks, -f<span style=color:#f92672>)</span> unlimited
</span></span><span style=display:flex><span>pending signals                 <span style=color:#f92672>(</span>-i<span style=color:#f92672>)</span> <span style=color:#ae81ff>15065</span>
</span></span><span style=display:flex><span>max locked memory       <span style=color:#f92672>(</span>kbytes, -l<span style=color:#f92672>)</span> <span style=color:#ae81ff>64</span>
</span></span><span style=display:flex><span>max memory size         <span style=color:#f92672>(</span>kbytes, -m<span style=color:#f92672>)</span> unlimited
</span></span><span style=display:flex><span>open files                      <span style=color:#f92672>(</span>-n<span style=color:#f92672>)</span> <span style=color:#ae81ff>1024</span>
</span></span><span style=display:flex><span>pipe size            <span style=color:#f92672>(</span><span style=color:#ae81ff>512</span> bytes, -p<span style=color:#f92672>)</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>POSIX message queues     <span style=color:#f92672>(</span>bytes, -q<span style=color:#f92672>)</span> <span style=color:#ae81ff>819200</span>
</span></span><span style=display:flex><span>real-time priority              <span style=color:#f92672>(</span>-r<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>stack size              <span style=color:#f92672>(</span>kbytes, -s<span style=color:#f92672>)</span> <span style=color:#ae81ff>8192</span>
</span></span><span style=display:flex><span>cpu time               <span style=color:#f92672>(</span>seconds, -t<span style=color:#f92672>)</span> unlimited
</span></span><span style=display:flex><span>max user processes              <span style=color:#f92672>(</span>-u<span style=color:#f92672>)</span> <span style=color:#ae81ff>15065</span>
</span></span><span style=display:flex><span>virtual memory          <span style=color:#f92672>(</span>kbytes, -v<span style=color:#f92672>)</span> unlimited
</span></span><span style=display:flex><span>file locks                      <span style=color:#f92672>(</span>-x<span style=color:#f92672>)</span> unlimited
</span></span></code></pre></div><p>open files那一行就代表系统目前允许单个进程打开的最大句柄数，这里是1024。</p><ul><li>使用命令<code>lsof -p 进程id</code>可以查看单个进程所有打开的文件详情，</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$lsof -p <span style=color:#ae81ff>18260</span>
</span></span><span style=display:flex><span>COMMAND   PID USER   FD      TYPE             DEVICE  SIZE/OFF     NODE NAME
</span></span><span style=display:flex><span>java    <span style=color:#ae81ff>18260</span> root  cwd       DIR              253,0        <span style=color:#ae81ff>95</span> <span style=color:#ae81ff>51010140</span> /usr/local/www/auth-provider
</span></span><span style=display:flex><span>java    <span style=color:#ae81ff>18260</span> root  rtd       DIR              253,0       <span style=color:#ae81ff>236</span>       <span style=color:#ae81ff>64</span> /
</span></span><span style=display:flex><span>java    <span style=color:#ae81ff>18260</span> root  txt       REG              253,0      <span style=color:#ae81ff>8534</span> <span style=color:#ae81ff>50882672</span> /usr/java/jdk1.8.0_191-amd64/jre/bin/java
</span></span><span style=display:flex><span>java    <span style=color:#ae81ff>18260</span> root  mem       REG              253,0    <span style=color:#ae81ff>283312</span> <span style=color:#ae81ff>17363896</span> /usr/java/jdk1.8.0_191-amd64/jre/lib/amd64/libsunec.so
</span></span><span style=display:flex><span>java    <span style=color:#ae81ff>18260</span> root  mem       REG              253,0     <span style=color:#ae81ff>93944</span> <span style=color:#ae81ff>17363886</span> /usr/java/jdk1.8.0_191-amd64/jre/lib/amd64/libnio.so
</span></span><span style=display:flex><span>java    <span style=color:#ae81ff>18260</span> root  mem       REG              253,0     <span style=color:#ae81ff>68192</span>    <span style=color:#ae81ff>51221</span> /usr/lib64/libbz2.so.1.0.6
</span></span><span style=display:flex><span>java    <span style=color:#ae81ff>18260</span> root  mem       REG              253,0    <span style=color:#ae81ff>157424</span>    <span style=color:#ae81ff>51208</span> /usr/lib64/liblzma.so.5.2.2
</span></span><span style=display:flex><span>…	…	…	…	…	…	…	…
</span></span></code></pre></div><ul><li>使用命令<code>lsof -p 进程id | wc -l</code>可以统计进程打开了多少文件</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ lsof -p 18260| wc -l
</span></span><span style=display:flex><span><span style=color:#ae81ff>317</span>
</span></span></code></pre></div><p>如果文件数过多使用<code>lsof -p 进程id</code>命令无法完全查看的话，可以使用<code>lsof -p 进程id > openfiles.log</code>将执行结果内容输出到日志文件中查看。</p><h2 id=解决方法>解决方法</h2><ul><li>增大允许打开的文件数——命令方式</li></ul><pre tabindex=0><code>ulimit -n 2048
</code></pre><p>这样就可以把当前用户的最大允许打开文件数量设置为2048了，但这种设置方法在重启后会还原为默认值。
<code>ulimit -n命令</code> 非root用户只能设置到4096。想要设置到更大需要sudo权限或者root用户。</p><ul><li>增大允许打开的文件数——修改系统配置文件</li></ul><p>修改配置文件<code>/etc/security/limits.conf</code>在最后加入</p><pre tabindex=0><code>* soft nofile 4096  
* hard nofile 4096  
</code></pre><p>或者只加入</p><pre tabindex=0><code> * - nofile 8192
</code></pre><p>最前的 * 表示所有用户，可根据需要设置某一用户，例如</p><pre tabindex=0><code>roy soft nofile 8192  
roy hard nofile 8192  
</code></pre><p>注意”nofile”项有两个可能的限制措施。就是项下的hard和soft。 要使修改过得最大打开文件数生效，必须对这两种限制进行设定。 如果使用”-“字符设定, 则hard和soft设定会同时被设定。</p><ul><li>检查程序问题</li></ul><p>如果你对你的程序有一定的解的话，应该对程序打开文件数(链接数)上限有一定的估算，如果感觉数字异常，请使用第一步的lsof -p 进程id > openfiles.log命令，获得当前占用句柄的全部详情进行分析。</p><h2 id=我遇到的问题>我遇到的问题</h2><p>在分析 lsof 返回的详情中，发现socket数据一直增加，觉得是某个资源未释放，导致的。在http请求方面使用<code>hutool-v4.5.0版本</code>，此版本的http请求工具类有缺陷。升级至最新，即可解决。</p><ul class=pa0><li class="list di"><a href=/tags/tools/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">tools</a></li><li class="list di"><a href=/tags/java/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">java</a></li><li class="list di"><a href=/tags/debug/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">debug</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/blog/mybatis-auto-id/>MyBatis获取插入记录的自增长字段值</a></li><li class=mb2><a href=/blog/apache-maven-source-plugin-usage/>Apache Maven Source Plugin-Maven打包源码到私服</a></li><li class=mb2><a href=/blog/check-port/>各个系统查看端口情况的方法</a></li><li class=mb2><a href=/blog/mysql-dump-usage/>使用mysqldump导出mysql表结构和表数据</a></li><li class=mb2><a href=/blog/troubleshooting-of-high-cpu-consumption-of-online-java-programs/>线上java程序CPU占用过高问题排查</a></li></ul></div></aside><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7732072032123305" crossorigin=anonymous></script>
<ins class=adsbygoogle style=display:block data-ad-client=ca-pub-7732072032123305 data-ad-slot=6735921740 data-ad-format=auto data-full-width-responsive=true></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://linkall.pub/>&copy; 逆天改命 2024</a><div><div class=ananke-socials></div></div></div></footer></body></html>