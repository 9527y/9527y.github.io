<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>mysql bin-log 误操作数据修复 | 逆天改命</title><meta name=google-adsense-account content="ca-pub-7732072032123305"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=keywords content><meta name=description content="先说原理 基于全量备份，加bin-log，将数据恢复到误操作之前节点数据，然后跳过误操作，执行后面操作。使用binlog文件转成sql执行，导入到数据库。
查看binlog文件 如果有多个binlog日志也可以在Mysql命令行下查看当前binlog、切割binlog日志。切割完成binlog再次查看就会看到新的日志写入到新的binlog文件中。
mysql> show master status; +------------------+-----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+-----------+--------------+------------------+-------------------+ | mysql-bin.000001 | 343629748 | | | | +------------------+-----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) mysql> flush logs; Query OK, 0 rows affected (0.01 sec) 找到binlog中错误的语句 使用mysqlbinlog命令加参数，可以指定时间段，和pos节点：
--start-position 起始点 --stop-position 结束点（不包含） --start-datetime=“2017--11-01 00:00:00” 起始时间 --stop-datetime=&#34;2017-11-11 00:00:00&#34; 终止时间 -d db_name 指定数据库 -v 是显示出一些sql的信息 -vv 则是多一些注释性的东西 --base64-output=DECODE-ROWS 这个是把sql解码出来 可以binlog日志中找到错误语句执行的时间点，分别恢复错误语句前后的binlog日志为sql。也可以跳过此步，直接恢复整个binlog日志为sql，然后打开sql文件，删除错误语句。
可以根据时间点来确定误操作的确切时间 mysqlbinlog --no-defaults --database=order --start-datetime='2019-11-02 3:08' --stop-datetime='2019-11-02 23:08' --base64-output=DECODE-ROWS mysql-bin."><meta name=generator content="Hugo 0.119.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><link rel=canonical href=https://linkall.pub/blog/mysql-bin-log-reverse/><meta property="og:title" content="mysql bin-log 误操作数据修复"><meta property="og:description" content="先说原理 基于全量备份，加bin-log，将数据恢复到误操作之前节点数据，然后跳过误操作，执行后面操作。使用binlog文件转成sql执行，导入到数据库。
查看binlog文件 如果有多个binlog日志也可以在Mysql命令行下查看当前binlog、切割binlog日志。切割完成binlog再次查看就会看到新的日志写入到新的binlog文件中。
mysql> show master status; +------------------+-----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+-----------+--------------+------------------+-------------------+ | mysql-bin.000001 | 343629748 | | | | +------------------+-----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) mysql> flush logs; Query OK, 0 rows affected (0.01 sec) 找到binlog中错误的语句 使用mysqlbinlog命令加参数，可以指定时间段，和pos节点：
--start-position 起始点 --stop-position 结束点（不包含） --start-datetime=“2017--11-01 00:00:00” 起始时间 --stop-datetime=&#34;2017-11-11 00:00:00&#34; 终止时间 -d db_name 指定数据库 -v 是显示出一些sql的信息 -vv 则是多一些注释性的东西 --base64-output=DECODE-ROWS 这个是把sql解码出来 可以binlog日志中找到错误语句执行的时间点，分别恢复错误语句前后的binlog日志为sql。也可以跳过此步，直接恢复整个binlog日志为sql，然后打开sql文件，删除错误语句。
可以根据时间点来确定误操作的确切时间 mysqlbinlog --no-defaults --database=order --start-datetime='2019-11-02 3:08' --stop-datetime='2019-11-02 23:08' --base64-output=DECODE-ROWS mysql-bin."><meta property="og:type" content="article"><meta property="og:url" content="https://linkall.pub/blog/mysql-bin-log-reverse/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-06-01T18:25:23+00:00"><meta property="article:modified_time" content="2020-06-01T18:25:23+00:00"><meta itemprop=name content="mysql bin-log 误操作数据修复"><meta itemprop=description content="先说原理 基于全量备份，加bin-log，将数据恢复到误操作之前节点数据，然后跳过误操作，执行后面操作。使用binlog文件转成sql执行，导入到数据库。
查看binlog文件 如果有多个binlog日志也可以在Mysql命令行下查看当前binlog、切割binlog日志。切割完成binlog再次查看就会看到新的日志写入到新的binlog文件中。
mysql> show master status; +------------------+-----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+-----------+--------------+------------------+-------------------+ | mysql-bin.000001 | 343629748 | | | | +------------------+-----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) mysql> flush logs; Query OK, 0 rows affected (0.01 sec) 找到binlog中错误的语句 使用mysqlbinlog命令加参数，可以指定时间段，和pos节点：
--start-position 起始点 --stop-position 结束点（不包含） --start-datetime=“2017--11-01 00:00:00” 起始时间 --stop-datetime=&#34;2017-11-11 00:00:00&#34; 终止时间 -d db_name 指定数据库 -v 是显示出一些sql的信息 -vv 则是多一些注释性的东西 --base64-output=DECODE-ROWS 这个是把sql解码出来 可以binlog日志中找到错误语句执行的时间点，分别恢复错误语句前后的binlog日志为sql。也可以跳过此步，直接恢复整个binlog日志为sql，然后打开sql文件，删除错误语句。
可以根据时间点来确定误操作的确切时间 mysqlbinlog --no-defaults --database=order --start-datetime='2019-11-02 3:08' --stop-datetime='2019-11-02 23:08' --base64-output=DECODE-ROWS mysql-bin."><meta itemprop=datePublished content="2020-06-01T18:25:23+00:00"><meta itemprop=dateModified content="2020-06-01T18:25:23+00:00"><meta itemprop=wordCount content="121"><meta itemprop=keywords content="mysql,"><meta name=twitter:card content="summary"><meta name=twitter:title content="mysql bin-log 误操作数据修复"><meta name=twitter:description content="先说原理 基于全量备份，加bin-log，将数据恢复到误操作之前节点数据，然后跳过误操作，执行后面操作。使用binlog文件转成sql执行，导入到数据库。
查看binlog文件 如果有多个binlog日志也可以在Mysql命令行下查看当前binlog、切割binlog日志。切割完成binlog再次查看就会看到新的日志写入到新的binlog文件中。
mysql> show master status; +------------------+-----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+-----------+--------------+------------------+-------------------+ | mysql-bin.000001 | 343629748 | | | | +------------------+-----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) mysql> flush logs; Query OK, 0 rows affected (0.01 sec) 找到binlog中错误的语句 使用mysqlbinlog命令加参数，可以指定时间段，和pos节点：
--start-position 起始点 --stop-position 结束点（不包含） --start-datetime=“2017--11-01 00:00:00” 起始时间 --stop-datetime=&#34;2017-11-11 00:00:00&#34; 终止时间 -d db_name 指定数据库 -v 是显示出一些sql的信息 -vv 则是多一些注释性的东西 --base64-output=DECODE-ROWS 这个是把sql解码出来 可以binlog日志中找到错误语句执行的时间点，分别恢复错误语句前后的binlog日志为sql。也可以跳过此步，直接恢复整个binlog日志为sql，然后打开sql文件，删除错误语句。
可以根据时间点来确定误操作的确切时间 mysqlbinlog --no-defaults --database=order --start-datetime='2019-11-02 3:08' --stop-datetime='2019-11-02 23:08' --base64-output=DECODE-ROWS mysql-bin."></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">逆天改命</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Blogs</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">mysql bin-log 误操作数据修复</h1><time class="f6 mv4 dib tracked" datetime=2020-06-01T18:25:23Z>June 1, 2020</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id=先说原理>先说原理</h1><p>基于全量备份，加bin-log，将数据恢复到误操作之前节点数据，然后跳过误操作，执行后面操作。使用binlog文件转成sql执行，导入到数据库。</p><h2 id=查看binlog文件>查看binlog文件</h2><p>如果有多个binlog日志也可以在Mysql命令行下查看当前binlog、切割binlog日志。切割完成binlog再次查看就会看到新的日志写入到新的binlog文件中。</p><pre tabindex=0><code>mysql&gt; show master status;
+------------------+-----------+--------------+------------------+-------------------+
| File             | Position  | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+-----------+--------------+------------------+-------------------+
| mysql-bin.000001 | 343629748 |              |                  |                   |
+------------------+-----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)

mysql&gt; flush logs;
Query OK, 0 rows affected (0.01 sec)
</code></pre><h2 id=找到binlog中错误的语句>找到binlog中错误的语句</h2><p>使用mysqlbinlog命令加参数，可以指定时间段，和pos节点：</p><pre tabindex=0><code>--start-position    起始点
--stop-position     结束点（不包含）
--start-datetime=“2017--11-01 00:00:00”     起始时间
--stop-datetime=&#34;2017-11-11 00:00:00&#34;       终止时间
-d db_name          指定数据库
-v                  是显示出一些sql的信息 
-vv                 则是多一些注释性的东西
--base64-output=DECODE-ROWS 这个是把sql解码出来
</code></pre><p>可以binlog日志中找到错误语句执行的时间点，分别恢复错误语句前后的binlog日志为sql。也可以跳过此步，直接恢复整个binlog日志为sql，然后打开sql文件，删除错误语句。</p><ul><li>可以根据时间点来确定误操作的确切时间</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mysqlbinlog  --no-defaults --database<span style=color:#f92672>=</span>order  --start-datetime<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;2019-11-02 3:08&#39;</span> --stop-datetime<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;2019-11-02 23:08&#39;</span> --base64-output<span style=color:#f92672>=</span>DECODE-ROWS mysql-bin.000004 &gt; neworder.sql
</span></span></code></pre></div><ul><li>根据position确定误操作之前的节点</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mysqlbinlog  --no-defaults --database<span style=color:#f92672>=</span>order --start-position<span style=color:#f92672>=</span><span style=color:#ae81ff>756577992</span>  --stop-position<span style=color:#f92672>=</span><span style=color:#ae81ff>775926228</span> --base64-output<span style=color:#f92672>=</span>DECODE-ROWS mysql-bin.000004 &gt; neworder.sql
</span></span></code></pre></div><ul><li>过滤误删除的sql</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># sudo mysqlbinlog --base64-output=DECODE-ROWS -v -d ids mysql-bin.000001 | grep --ignore-case -A3 -B4 &#39;错误的sql语句&#39;</span>
</span></span></code></pre></div><h2 id=恢复数据时>恢复数据时</h2><p>恢复数据准备前确认已经存在如下文件：</p><ol><li>误操作前的完整备份</li><li>全量备份到误操作前的执行sql</li><li>误操作后的执行sql</li></ol><p>进行数据恢复时开启读锁</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#f92672>&gt;</span> flush tables <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>read</span> <span style=color:#66d9ef>lock</span>;
</span></span></code></pre></div><p>然后依次还原1，2，3；最后把数据库锁解开</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#f92672>&gt;</span> unlock tables;
</span></span></code></pre></div><ul class=pa0><li class="list di"><a href=/tags/mysql/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">mysql</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/blog/mysql-base-config/>MySQL初始化基础配置</a></li><li class=mb2><a href=/blog/centos7-install-mysql/>一步一步CentOS7 安装 MySQL5.7</a></li><li class=mb2><a href=/blog/mysql-sql-monitor/>使用general_log来对Mysql SQL语句监控查看的记录</a></li><li class=mb2><a href=/blog/mysql-dump-usage/>使用mysqldump导出mysql表结构和表数据</a></li><li class=mb2><a href=/blog/mysql-view-database-table-capacity/>MySQL查看数据库表容量大小</a></li></ul></div></aside><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7732072032123305" crossorigin=anonymous></script>
<ins class=adsbygoogle style=display:block data-ad-client=ca-pub-7732072032123305 data-ad-slot=6735921740 data-ad-format=auto data-full-width-responsive=true></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://linkall.pub/>&copy; 逆天改命 2024</a><div><div class=ananke-socials></div></div></div></footer></body></html>