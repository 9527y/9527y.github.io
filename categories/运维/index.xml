<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>运维 :: Category :: 逆天改命</title><link>https://linkall.pub/categories/%E8%BF%90%E7%BB%B4/index.html</link><description/><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 18 May 2024 09:19:40 +0000</lastBuildDate><atom:link href="https://linkall.pub/categories/%E8%BF%90%E7%BB%B4/index.xml" rel="self" type="application/rss+xml"/><item><title>获取最新的GoogleDriver，下载指定版本</title><link>https://linkall.pub/blog/get-the-newest-chromedriver/index.html</link><pubDate>Sat, 18 May 2024 09:19:40 +0000</pubDate><guid>https://linkall.pub/blog/get-the-newest-chromedriver/index.html</guid><description>对于114之前的版本参考： https://developer.chrome.com/docs/chromedriver/downloads
对于114之后的版本访问：
下载最新版本 获取地址：https://googlechromelabs.github.io/chrome-for-testing
下载制定版本 可能chrome的版本不是最新的，所以需要指定版本。在最新版本中得到地址：https://storage.googleapis.com/chrome-for-testing-public/125.0.6422.60/mac-arm64/chromedriver-mac-arm64.zip
在url中有一段是版本号，根据你的chrome版本，替换那个版本号，比如我用的是124.0.6367.203。所以得到的下载地址是：
https://storage.googleapis.com/chrome-for-testing-public/125.0.6422.60/mac-arm64/chromedriver-mac-arm64.zip</description></item><item><title>尼日利亚手机号匹配运营商规则</title><link>https://linkall.pub/blog/nigeria-tel-operator-rule/index.html</link><pubDate>Tue, 14 May 2024 09:32:00 +0000</pubDate><guid>https://linkall.pub/blog/nigeria-tel-operator-rule/index.html</guid><description>在尼日利亚，不同的移动运营商分配了特定的手机号段，通过这些号码段可以区分是哪家运营商提供的服务。以下是尼日利亚主要移动运营商及其对应的手机号段规则：
主要运营商及其号码段 MTN Nigeria
0703 0706 0803 0806 0810 0813 0814 0816 0903 0906 0913 0916 Globacom (Glo)
0705 0805 0807 0811 0815 0905 Airtel Nigeria
0701 0708 0802 0808 0812 0901 0902 0904 0907 0912 9mobile (原Etisalat Nigeria)
0809 0817 0818 0909 0908 如何使用这些号码段规则 通过识别手机号的前三位或四位数字，你可以确定该号码归属的运营商。例如：
0803 123 4567：号码段为0803，属于MTN Nigeria。 0815 987 6543：号码段为0815，属于Globacom (Glo)。 0701 234 5678：号码段为0701，属于Airtel Nigeria。 0809 876 5432：号码段为0809，属于9mobile。 例外情况 需要注意的是，随着号码携带服务（number portability）的引入，用户可以在不更改电话号码的情况下更换运营商。因此，仅通过号码段来判断运营商可能不完全准确，但仍然是一个非常有用的初步识别工具。</description></item><item><title>Nginx 配置反向代理去除前缀</title><link>https://linkall.pub/blog/nginx-remove-prefix/index.html</link><pubDate>Sat, 30 Mar 2024 17:07:54 +0000</pubDate><guid>https://linkall.pub/blog/nginx-remove-prefix/index.html</guid><description>使用Nginx做反向代理的时候如果需要根据不同的url代理到不同的服务器，需要通过以下 法：
地址后面加/ server { location ^~/v1/ { proxy_pass http://localhost:8080/; } }^~/v1/表示请求前缀是v1的请求，proxy_pass最后加上/，就会把v1去除，比如请求的地址是v1/api/test，则代理发出的请求是http://localhost:8080/api/test
使用rewrite server { location ^~/v1/ { rewrite ^/v1/(.*)$ /$1 break; proxy_pass http://localhost:8080; } }使用 rewrite重写了url，注意 proxy_pass后不需要加/</description></item><item><title>docker修改存储位置</title><link>https://linkall.pub/blog/docker-modify-storage/index.html</link><pubDate>Mon, 05 Jun 2023 12:52:58 +0000</pubDate><guid>https://linkall.pub/blog/docker-modify-storage/index.html</guid><description>[toc]
背景 因为随着容器启动越来越多，存储占据越来越多的空间：/var/lib/docker/overlay2/，所以修改挂载位置，可以是外部空间等。
修改存储位置 停止服务 systemctl stop docker 将存储路径复制到新目录下 &lt;新目录> mkdir -p &lt;新目录> sudo rsync -aqxP /var/lib/docker/ &lt;新目录> 修改启动脚本/lib/systemd/system/docker.service。 # 将 [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock # 修改为 ExecStart=/usr/bin/dockerd -g &lt;新目录> -H fd:// --containerd=/run/containerd/containerd.sock 重启服务 systemctl daemon-reload; systemctl start docker; 之前的目录可以清理了。</description></item><item><title>镜像版本说明</title><link>https://linkall.pub/blog/docker-image-version-intro/index.html</link><pubDate>Wed, 16 Mar 2022 00:43:22 +0000</pubDate><guid>https://linkall.pub/blog/docker-image-version-intro/index.html</guid><description>不同的tag表示给予不同的base image。
debian linux 版本代号
Debian 11（"bullseye"） — 下一代发布时间尚未确定 Debian 10（"buster"）- 当前的稳定版（stable） Debian 9（"stretch"）- 旧的稳定版（oldoldstable） Debian 8（"jessie"） — 更旧的稳定版（oldoldstable） Debian 7（"wheezy"） — 被淘汰的稳定版 Debian 6.0（"squeeze"） — 被淘汰的稳定版 Debian GNU/Linux 5.0（"lenny"） — 被淘汰的稳定版 Debian GNU/Linux 4.0（"etch"） — 被淘汰的稳定版 Debian GNU/Linux 3.1（"sarge"） — 被淘汰的稳定版 Debian GNU/Linux 3.0（"woody"） — 被淘汰的稳定版 Debian GNU/Linux 2.2（"potato"） — 被淘汰的稳定版 Debian GNU/Linux 2.1（"slink"） — 被淘汰的稳定版 Debian GNU/Linux 2.0（"hamm"） — 被淘汰的稳定版 alpine：本意是高山的，是一个面向安全的轻型 Linux 发行版。和Debian一样都是Linux的一种发行版本。此版本系统特点是小巧、安全、简单、适合容器使用。 buster：Debian版本，类似的还有Jessie（2015年发行的）、wheezy （2013年发行） slim：镜像的瘦身版。大概意思是通过动态和静态的分析，去除不必要的依赖，缩减镜像的大小 ​前面说过，不同的tag是基于不同的base image构建的镜像。上面的alpine是基于该种Linux构建的，buster、stretch、jessie是基于相应的debian Linux版本构建的。slim是特殊的瘦身版。</description></item><item><title>架构师能力模型</title><link>https://linkall.pub/blog/architect-competency-model/index.html</link><pubDate>Tue, 15 Mar 2022 11:22:36 +0000</pubDate><guid>https://linkall.pub/blog/architect-competency-model/index.html</guid><description>架构师在很多人眼中是一个非常高大上的职业, 就像武侠小说中的绝世高手一样, 关键时刻可以起到扭转乾坤的作用, 是团队中的灵魂人物. 回想我自己做一线架构师的过程中, 也没有经历过比较系统的培训, 都是摸着石头过河. 近期在培养架构师的过程中, 促使我一直在思考, 一个合格的架构师到底应该具备哪些能力? 对希望成长为架构师的同学, 或者在承担架构师职责的同学, 需要提供哪些方面的指导和帮助, 才能让他逐步成长为合格的架构师呢? 下面我结合自己的经验, 总结了我认为对架构师来说非常重要的十项能力, 希望给那些努力成长为架构师的同学提供一点点帮助.
研发流程的持续改进 架构师不是单兵作战, 凭借个人英雄主义是无法做成大事的. 架构师一定是指挥一个团队来共同完成既定目标, 或者一个复杂项目. 在软件研发领域, 决定团队研发效率的核心在于研发流程的优化. 现阶段互联网公司大多采用敏捷研发流程, 这其中主要包括:
需求卡片的状态流转. 尽可能依靠工具实现状态的自动化流转, 减少人为操作的情况. 开发工具的选择. 比如web ide, 代码审查工具, 项目管理工具等. 代码的开发和审查(包括单测代码和测试流水线代码). 开发功能代码的同时, 必须同时提交单测代码和测试流水线代码, 保证新增代码的基本功能被覆盖. 尽量不要分开开发, 保证测试代码的质量. 测试流水线的建设和持续优化. 测试流水线需要在测试覆盖率和运行时间方面进行平衡, 测试覆盖率越大势必会增加测试时间, 如果每次提交pr, 都需要跑很长时间的测试流水线, 那么无疑会降低研发效率. 这时候可以采用测试case分级的方法, 设计ci pileline, daily pipeline, perf pipeline等多条测试流水线, 并且以不同的周期运行. 持续发布和持续部署. 敏捷开发模式核心就是希望通过小步快跑的方式优化传统瀑布模型的阶段性开发模式, 让每次迭代尽可能快速的得到效果反馈, 从而可以针对反馈更快速的进行软件迭代. 这就要求我们一定要有持续发布和部署的能力, 可以采用灰度发布, A/B test等模式. 架构师需要对研发流程的每个环节保持着敏锐的嗅觉, 可以及时发现其中的问题, 并提出有效的优化方法. 我们经常讨论架构师要不要写代码的问题, 在我看来, 不管架构师是否动手写代码, 一定要对代码保持敏感. 保持敏感的方法就是对研发流程保持足够的把控, 参与代码审查, 持续的优化研发流程.</description></item><item><title>Nginx转发websocket协议</title><link>https://linkall.pub/blog/nginx-sw-forward/index.html</link><pubDate>Fri, 07 Jan 2022 17:03:17 +0000</pubDate><guid>https://linkall.pub/blog/nginx-sw-forward/index.html</guid><description>Nginx转发 Nginx添加WebSocket的转发配置。
location /websocket/ { proxy_pass http://myserver; proxy_http_version 1.1; proxy_read_timeout 360s; proxy_redirect off; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; #配置连接为升级连接 proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; }使用如上连接，如果所有的连接仅仅为 “ws” 协议的请求是没有问题的，但是如果要及支持 http 请求又支持 ws 请求上述配置就不起作用了。
既支持http又支持 ws 的配置。 http { #自定义变量 $connection_upgrade map $http_upgrade $connection_upgrade { default keep-alive; #默认为keep-alive 可以支持 一般http请求 'websocket' upgrade; #如果为websocket 则为 upgrade 可升级的。 } server { ... location /chat/ { proxy_pass http://backend; proxy_http_version 1.</description></item><item><title>mac改写rm命令：移到废纸篓</title><link>https://linkall.pub/blog/mac-rename-rm-to-trash/index.html</link><pubDate>Mon, 28 Jun 2021 11:08:51 +0000</pubDate><guid>https://linkall.pub/blog/mac-rename-rm-to-trash/index.html</guid><description>使用trash脚本替换rm命令，它的实质是调用finder的api进行删除操作，也就是移除到废纸篓，也就拥有了废纸篓的恢复源文件功能。
安装trash 使用homebrew安装trash
$ brew install trash此时已经可以使用trash -fr filename，命令与rm一样。但是由于已经习惯性地使用rm命令，改成trash还是有时会习惯性地使用rm删除，因此将rm替换为trash
使用trash替换rm命令 在(~/.bash_profile|~/.zshrc)文件中将rm指向trash，添加下列语句。
## 安装了一个 trash 命令，替代 rm 命令，被删除的文件会放到垃圾桶 alias rm="trash"使用source命令生效。
此时使用rm命令删除文件后会发现文件在废纸篓里了，而且可以使用放回原处的功能。</description></item><item><title>kubernetes coredns无法解析私有harbor域名问题处理</title><link>https://linkall.pub/blog/k8s-coredns-looksup-local-harbor-domain/index.html</link><pubDate>Thu, 03 Jun 2021 08:29:14 +0000</pubDate><guid>https://linkall.pub/blog/k8s-coredns-looksup-local-harbor-domain/index.html</guid><description>修改coredns配置，增加host对应；
1,/etc/hosts 添加相关的域名解析 xx.xx.xx.xx harbor.alexdev.com 2，修改coredns configmap，添加hosts语段： # kubectl get cm coredns -n kube-system -o yaml apiVersion: v1 data: Corefile: | .:53 { errors health { lameduck 5s } ready kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } ## 主要为以下内容(注意末尾添加 .cluster.local)： ## hosts内部可以添加多个域名 hosts { xx.xx.xx.xx harbor.alexdev.com.cluster.local fallthrough } prometheus :9153 forward . /etc/resolv.conf { prefer_udp } 3,添加后，如果pod内仍无法ping通域名，可以删除coredns pod，重新加载cm文件 # kubectl get pods -A|grep coredns kube-system coredns-6b55b6764d-7wdsq 1/1 Running 1 18h kube-system coredns-6b55b6764d-d4q72 1/1 Running 1 18h # kubectl delete pod coredns-6b55b6764d-7wdsq -n kube-system # kubectl delete pod coredns-6b55b6764d-d4q72 -n kube-system 4,测试 kubectl run -i --tty --image busybox:1.</description></item><item><title>在Mac下远程登录Linux时,提示cannot change locale (UTF-8) No such file or directory</title><link>https://linkall.pub/blog/setlocale-lc-ctype-cannot-change-locale/index.html</link><pubDate>Wed, 05 May 2021 20:30:12 +0000</pubDate><guid>https://linkall.pub/blog/setlocale-lc-ctype-cannot-change-locale/index.html</guid><description>问题描述 Mac下设置第一语言为English 在Terminal或者iTerm2上登录远端Linux时，Linux的prompt提示 setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory 登录Linux后无法正常显示中文 原因 Mac下设置为英文后，locale字符集默认是”C”，Terminal或者iTerm2中有选项会自动设置LC_CTYPE或者LC_LANG为UTF-8 Mac下ssh客户端的配置文件/etc/ssh/ssh_config中，会尝试设置本地的LANG到远端服务器中。 远端Linux服务器，没有UTF-8的字符集，就导致了setlocale的警报 解决办法 为了登录而来，修改每个服务器的字符集，操作上是不可行的。最简单的办法就是修改Mac本地的ssh客户端配置，不要将LANG设置发送到服务器端。 打开ssh配置文件，sudo vim /etc/ssh/ssh_config, 注释掉如下几行
Host * SendEnv LANG LC_*重新ssh到服务器，就不会再有setlocale的告警了。</description></item><item><title>CentOS7设置内核启动顺序</title><link>https://linkall.pub/blog/centos-grub2-modify/index.html</link><pubDate>Thu, 15 Apr 2021 09:12:47 +0000</pubDate><guid>https://linkall.pub/blog/centos-grub2-modify/index.html</guid><description>1、查看设备上安装了几个内核
$ cat /boot/grub2/grub.cfg |grep menuentry if [ x"${feature_menuentry_id}" = xy ]; then menuentry_id_option="--id" menuentry_id_option="" export menuentry_id_option menuentry 'CentOS Linux (3.10.0-1160.24.1.el7.x86_64) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-3.10.0-1127.el7.x86_64-advanced-1760fedb-5552-4ad8-97c1-d1cf555ce12a' { menuentry 'CentOS Linux (5.4.111-1.el7.elrepo.x86_64) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-3.10.0-1127.el7.x86_64-advanced-1760fedb-5552-4ad8-97c1-d1cf555ce12a' { menuentry 'CentOS Linux (3.10.0-1127.el7.x86_64) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-3.10.0-1127.el7.x86_64-advanced-1760fedb-5552-4ad8-97c1-d1cf555ce12a' { menuentry 'CentOS Linux (0-rescue-c37a4d8b3c8d46958beaeafb2f03d2ba) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-0-rescue-c37a4d8b3c8d46958beaeafb2f03d2ba-advanced-1760fedb-5552-4ad8-97c1-d1cf555ce12a' {2、查看当前内核</description></item><item><title>Linux系统消除未被及时释放的TIME_WAIT状态的TCP连接</title><link>https://linkall.pub/blog/time-wait/index.html</link><pubDate>Fri, 09 Apr 2021 15:13:09 +0000</pubDate><guid>https://linkall.pub/blog/time-wait/index.html</guid><description>Linux系统下，TCP连接断开后，会以TIME_WAIT状态保留一定的时间，然后才会释放端口。当并发请求过多的时候，就会产生大量的TIME_WAIT状态的连接，无法及时断开的话，会占用大量的端口资源和服务器资源。这个时候我们可以优化TCP的内核参数，来及时将TIME_WAIT状态的端口清理掉。
[root@web1 ~]netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' TIME_WAIT 1280 FIN_WAIT1 7 SYN_SENT 1 FIN_WAIT2 7 ESTABLISHED 247 LAST_ACK 1我们只用关心TIME_WAIT的个数，在这里可以看到，有1280多个TIME_WAIT，这样就占用了1280多个端口，端口的数量只有65535个，占用一个少一个，会严重的影响到后继的新连接，就需调整下Linux的TCP内核参数，让系统更快的释放TIME_WAIT连接。
vi /etc/sysctl.conf 增加如下内容：
net.ipv4.tcp_syncookies = 1 #表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； net.ipv4.tcp_tw_reuse = 1 #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1 #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭； net.ipv4.tcp_fin_timeout = 30 #修改系統默认的 TIMEOUT 时间。sysctl -p 让内核参数生效 流量小的机器一般就可以了，如果是大流量机器增加如下参数：
net.ipv4.tcp_keepalive_time = 1200 #表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。 net.ipv4.ip_local_port_range = 10000 65000 #表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！） net.ipv4.tcp_max_syn_backlog = 8192 #表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。 net.ipv4.tcp_max_tw_buckets = 6000 #表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认180000，改为6000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死。 内核其他TCP参数说明： net.</description></item><item><title>nginx 80端口重定向到443端口</title><link>https://linkall.pub/blog/nginx-ssl/index.html</link><pubDate>Sun, 07 Feb 2021 15:58:32 +0000</pubDate><guid>https://linkall.pub/blog/nginx-ssl/index.html</guid><description>使用如下配置即可
server { listen 80; server_name www.test.com; rewrite ^(.*)$ https://${server_name}$1 permanent; }</description></item><item><title>vue-router的history模式nginx配置</title><link>https://linkall.pub/blog/vue-router-history-nginx-config/index.html</link><pubDate>Wed, 06 Jan 2021 17:15:12 +0000</pubDate><guid>https://linkall.pub/blog/vue-router-history-nginx-config/index.html</guid><description>原理是：将解析转为index.html页面
server { listen 80; server_name avue-data.meipinshu.cn; location / { index index.html; root /data/wwwroot; try_files $uri $uri/ /index.html; } }</description></item><item><title>mac终端Iterm2支持rz和sz的解决方案</title><link>https://linkall.pub/blog/mac-lrzsz/index.html</link><pubDate>Tue, 15 Dec 2020 19:31:37 +0000</pubDate><guid>https://linkall.pub/blog/mac-lrzsz/index.html</guid><description>在mac下，实现与服务器进行便捷的文件上传和下载操作：
安装支持rz和sz命令的lrzsz：
brew install lrzsz在本地/usr/local/bin/目录下保存iterm2-send-zmodem.sh 和iterm2-recv-zmodem.sh两个脚本
两个文件链接：https://github.com/aikuyun/iterm2-zmodem
设置一下两个脚本的权限，一般 chmod 777 就行了 设置Iterm2的Tirgger特性，profiles->default->editProfiles->Advanced中的Tirgger
添加两条trigger，分别设置Regular expression，Action，Parameters，Instant如下： 1.第一条 Regular expression: rz waiting to receive.\*\*B0100 Action: Run Silent Coprocess Parameters: /usr/local/bin/iterm2-send-zmodem.sh Instant: checked 2.第二条 Regular expression: \*\*B00000000000000 Action: Run Silent Coprocess Parameters: /usr/local/bin/iterm2-recv-zmodem.sh Instant: checked</description></item><item><title>本地代理pac文件</title><link>https://linkall.pub/blog/pac-file/index.html</link><pubDate>Sun, 06 Dec 2020 12:35:54 +0000</pubDate><guid>https://linkall.pub/blog/pac-file/index.html</guid><description>// Generated by gfwlist2pac in precise mode // https://github.com/clowwindy/gfwlist2pac var proxy = "SOCKS5 10.10.10.1:1080; SOCKS 10.10.10.1:1080; DIRECT;"; var rules = [ "|http:\/\/85.17.73.31\/", "||clipconverter.cc", "||agnesb.fr", "||akiba-web.com", "||altrec.com", "||angela-merkel.de", "||angola.org", "||apartmentratings.com", "||apartments.com", "||arena.taipei", "||asianspiss.com", "||assimp.org", "||athenaeizou.com", "||azubu.tv", "||bankmobilevibe.com", "||banorte.com", "||bash-hackers.org", "||beeg.com", "||global.bing.com", "||bloombergview.com", "||booktopia.com.au", "||boysmaster.com", "||bynet.co.il", "||carfax.com", ".casinobellini.com", "||casinobellini.com", "||centauro.com.br", "||chobit.cc", "||clearsurance.com", "||images.comico.tw", "||static.comico.tw", "||counter.social", "||costco.com", "||crossfire.co.kr", "||d2pass.com", "||darpa.mil", "||dawangidc.com", "||deezer.com", "||desipro.de", "||dingchin.com.tw", "||discord.com", "||discord.gg", "||discordapp.com", "||discordapp.net", "||dish.com", "|http:\/\/img.dlsite.jp\/", "||dm530.net", "share.dmhy.org", "||dmhy.org", "||dmm.</description></item><item><title>CentOS 7 配置 Supervisor</title><link>https://linkall.pub/blog/supervisor-handbook/index.html</link><pubDate>Sat, 21 Nov 2020 11:58:04 +0000</pubDate><guid>https://linkall.pub/blog/supervisor-handbook/index.html</guid><description>Supervisor 的文档地址：http://www.supervisord.org/
安装 Supervisor yum install -y epel-release yum install -y supervisor2. 配置 Supervisor Supervisor 的配置文件为：/etc/supervisord.conf ，Supervisor 所管理的应用的配置文件放在 /etc/supervisord.d/ 目录中，这个目录可以在 supervisord.conf 中配置。
启动 Supervisor supervisord -c /etc/supervisor.conf通过这种方式启动，服务器重启后 Supervisor 不会自动启动，不建议使用这种方式启动Supervisor。
安装 Supervisor 后，在 /usr/lib/systemd/system/ 目录中会有一个 supervisord.service 文件，用下面的内容替换：
# supervisord service for sysstemd (CentOS 7.0+) # by ET-CS (https://github.com/ET-CS) [Unit] Description=Supervisor daemon [Service] Type=forking ExecStart=/usr/bin/supervisord ExecStop=/usr/bin/supervisorctl $OPTIONS shutdown ExecReload=/usr/bin/supervisorctl $OPTIONS reload KillMode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target启用开机启动
systemctl enable supervisord.service启动Supervisor
systemctl start supervisord.service查看Supervisor状态</description></item><item><title>Centos7 安装 Python3.8</title><link>https://linkall.pub/blog/centos-install-python3/index.html</link><pubDate>Mon, 12 Oct 2020 16:33:26 +0000</pubDate><guid>https://linkall.pub/blog/centos-install-python3/index.html</guid><description>目录TOC
Step 1 – 安装前准备 可以切换到阿里云yum源：
sudo yum -y update必备包
sudo yum -y install wget yum-utils gcc openssl-devel bzip2-devel libffi-devel zlib zlib-develStep 2 – 源码下载编译 cd /tmp/ wget https://www.python.org/ftp/python/3.8.6/Python-3.8.6.tgz tar xzf Python-3.8.6.tgz cd Python-3.8.6sudo ./configure --prefix=/opt/python38 --enable-optimizations --with-lto --with-system-ffi --with-computed-gotos --enable-loadable-sqlite-extensions sudo make -j "$(nproc)" sudo make altinstall如果提示：
/usr/local/bin/python: can't decompress data; zlib not available安装目录/Modules/Setup ，将#zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz的注释去掉。
Step 3 - 安装后操作 sudo ln -s /opt/python38/bin/python3.8 /opt/python38/bin/python3 sudo ln -s /opt/python38/bin/python3.</description></item><item><title>CentOS7使用阿里yum源</title><link>https://linkall.pub/blog/centos-use-aliyun-yum-source/index.html</link><pubDate>Mon, 12 Oct 2020 16:31:14 +0000</pubDate><guid>https://linkall.pub/blog/centos-use-aliyun-yum-source/index.html</guid><description>目录 [toc]
禁用 yum插件 fastestmirror 修改插件的配置文件 cp /etc/yum/pluginconf.d/fastestmirror.conf /etc/yum/pluginconf.d/fastestmirror.conf.bak vi /etc/yum/pluginconf.d/fastestmirror.conf enabled = 1由1改为0，禁用该插件
修改yum的配置文件 cp /etc/yum.conf /etc/yum.conf.bak vi /etc/yum.confplugins=1改为0，不使用插件
获取阿里云 repo cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo cp /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.bak wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo清理缓存，重建缓存 yum clean all yum makecache完工。</description></item><item><title>redis主从设置</title><link>https://linkall.pub/blog/redis-master-slave-replicate/index.html</link><pubDate>Mon, 10 Aug 2020 11:26:00 +0000</pubDate><guid>https://linkall.pub/blog/redis-master-slave-replicate/index.html</guid><description>预备知识： redis安装 配置 ##Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no ##当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid ##指定Redis监听端口，默认端口为6379 port 6379 # TCP接收队列长度，受/proc/sys/net/core/somaxconn和tcp_max_syn_backlog这两个内核参数的影响 tcp-backlog 511 ##绑定的主机地址 bind 127.0.0.1 ##当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 300 # 如果非零，则设置SO_KEEPALIVE选项来向空闲连接的客户端发送ACK,用来定时向client发送tcp_ack包来探测client是否存活的 tcp-keepalive 60 ##指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose ## debug （大量信息，对开发/测试有用） ## verbose （很多精简的有用信息，但是不像debug等级那么多） ## notice （适量的信息，基本上是你生产环境中需要的） ## warning （只有很重要/严重的信息会记录下来） loglevel verbose ##日志名 logfile "./redis7003.log" ##设置数据库的数量，可以使用SELECT &lt;dbid>命令在连接上指定数据库id databases 16 ##持久化rdb文件，指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合save &lt;seconds> &lt;changes> #Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 # 默认如果开启RDB快照(至少一条save指令)并且最新的后台保存失败，Redis将会停止接受写操作 # 这将使用户知道数据没有正确的持久化到硬盘，否则可能没人注意到并且造成一些灾难 stop-writes-on-bgsave-error yes ##指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes ###指定本地数据库文件名，默认值为dump.</description></item><item><title>redis哨兵机制</title><link>https://linkall.pub/blog/redis-sentinel-setting/index.html</link><pubDate>Fri, 31 Jul 2020 17:14:56 +0000</pubDate><guid>https://linkall.pub/blog/redis-sentinel-setting/index.html</guid><description>背景 我司使用仅有两台redis实例，所以不太适合做redis群集，比较适合使用redis哨兵机制。
原理 监控master故障时，使用投票机制（sdown，odown），判定是否故障，移除；选举新的slave作为master节点。redis.conf会随之变化。
哨兵机制关键配置 # 哨兵sentinel监控的redis主节点的 ip port # sentinel monitor &lt;master-name> &lt;ip> &lt;redis-port> &lt;quorum> sentinel monitor mymaster 172.16.8.206 6379 1 # Default is 3 minutes. 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒。 sentinel down-after-milliseconds mymaster 3000启动 ./redis-sentinel sentinel.conf注意 启动顺序：master->slave->sentinel master如果down掉，再启动不会他的角色是slave</description></item><item><title>redis 5.x安装</title><link>https://linkall.pub/blog/redis-5-install/index.html</link><pubDate>Fri, 31 Jul 2020 14:57:13 +0000</pubDate><guid>https://linkall.pub/blog/redis-5-install/index.html</guid><description>下载地址：
https://redis.io/download安装环境：
yum install -y gcc编译安装
make distclean &amp;&amp; make修改配置
vi redis.conf运行
src/redis-server redis.</description></item><item><title>cdn回源是什么意思</title><link>https://linkall.pub/blog/what-is-cdn-back-address/index.html</link><pubDate>Thu, 02 Jul 2020 13:33:28 +0000</pubDate><guid>https://linkall.pub/blog/what-is-cdn-back-address/index.html</guid><description>cdn回源是什么意思？CDN回源包括回源地址和加速域名。常规的CDN都是回源的。
原理 即：当有用户访问某一个URL的时候，如果被解析到的那个CDN节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么CDN节点不会主动去源站拿的。
回源地址 可以使回源域名，也可以是回源IP，主要作用是CDN加速节点同步更新的一个地址；
加速域名 使用CDN服务器需要加速的一个域名，一般会将加速域名做别名解析为CDN运营商提供的域名，来做CDN加速访问。
回源域名一般是cdn领域的专业术语，通常情况下，是直接用ip进行回源的，但是如果客户源站有多个ip，并且ip地址会经常变化，对于cdn厂商来说，为了避免经常更改配置（回源ip），会采用回源域名方式进行回源，这样即使源站的ip变化了，也不影响原有的配置。
CDN本来是给网站加速的，但是有时会因为不合适的回源策略给服务器带来负担，只有选择正确的策略才能给自己的网站带来更高的访问效率。</description></item><item><title>ssh 公钥认证方式登录（免密登录）</title><link>https://linkall.pub/blog/linux-ssh-login/index.html</link><pubDate>Wed, 01 Jul 2020 22:41:20 +0000</pubDate><guid>https://linkall.pub/blog/linux-ssh-login/index.html</guid><description>一般情况下,我们用ssh远程登录到服务器时，要输入用户名和密码。这对经常维护系统的人来说，很麻烦。怎样才能不用密码直接登录到远程的linux/unix服务器呢？ssh公钥认证可以解决这个问题。
公钥认证，是使用一对加密字符串，一个称为公钥(public key)， 任何人都可以看到其内容，用于加密；另一个称为密钥(private key)，只有拥有者才能看到，用于解密。 通过公钥加密过的密文使用密钥可以轻松解密，但根据公钥来猜测密钥却十分困难。
服务器端 在使用公钥认证之前，先检查一下服务器的ssh配置文件/etc/ssh/sshd_config
RSAAuthentication yes # 启用 RSA 认证，默认为yes PubkeyAuthentication yes # 启用公钥认证，默认为yes如果配置没有问题，那么你就可以进行下一步了。
例子 下面我们举个例子，比如有两台机器，客户机A与服务器B，想用ssh公钥认证方式从A机器用client用户登录到B机器的server用户，方法如下：
在客户机A上生成公钥与密钥 [client@test ~]$ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/home/client/.ssh/id_rsa): #此处直接按回车即可 Created directory '/home/client/.ssh'. Enter passphrase (empty for no passphrase): #此处直接按回车即可 Enter same passphrase again: #此处直接按回车即可 Your identification has been saved in /home/client/.ssh/id_rsa. Your public key has been saved in /home/client/.</description></item><item><title>Nginx 静态文件服务配置及优化</title><link>https://linkall.pub/blog/nginx-static-config/index.html</link><pubDate>Thu, 11 Jun 2020 10:22:54 +0000</pubDate><guid>https://linkall.pub/blog/nginx-static-config/index.html</guid><description>[TOC]
根目录和索引文件 root 指令指定将用于搜索文件的根目录。 为了获取所请求文件的路径，NGINX 将请求 URI 附加到 root 指令指定的路径。该指令可以放在 http {}，server {} 或 location {} 上下文中的任何级别。在下面的示例中，为虚拟服务器定义了 root 指令。 它适用于未包含根指令的所有location {} 块，以显式重新定义根：
server { root /www/data; location / { } location /images/ { } location ~ \.(mp3|mp4) { root /www/media; } }在这里，NGINX 针对 /images/ 开头的 URI 将在文件系统的 /www/ data/images/ 目录中搜索相应文件。 如果 URI 以 .mp3 或 .mp4 扩展名结尾，则 NGINX 会在 /www/media/ 目录中搜索该文件，因为它是在匹配的位置块中定义的。
如果请求以 / 结尾，则 NGINX 将其视为对目录的请求，并尝试在目录中查找索引文件。index 指令定义索引文件的名称（默认值为 index.html）。要继续该示例，如果请求 URI 是 /images/some/path/，则 NGINX 会返回文件 /www/data/images/some/path/index.</description></item><item><title>格式化并挂载数据盘</title><link>https://linkall.pub/blog/format-disk-mount-disk/index.html</link><pubDate>Tue, 02 Jun 2020 17:57:34 +0000</pubDate><guid>https://linkall.pub/blog/format-disk-mount-disk/index.html</guid><description>注意：
格式化后，数据盘中的数据将被全部清空。请在格式化之前，确保数据盘中没有数据或已对重要数据进行备份。为避免服务发生异常，格式化前请确保云服务器已停止对外服务。 手动格式化并挂载数据盘
请根据以下步骤格式化并挂载数据盘。
注意：
执行下述命令时，请注意修改数据盘盘符，本示例假设数据盘盘符为vdb。
步骤一：格式化数据盘 注意： 在进行分区格式化时，开发者可以自行决定文件系统的格式，如ext3、ext4等。示例采用ext4格式。
执行 mkfs 命令对数据盘进行格式化：
mkfs.ext4 /dev/vdb 步骤二：挂载数据盘 创建挂载点 data 目录：
mkdir /data 挂载新分区：
mount /dev/vdb /data 验证数据盘是否挂载成功：
df -h 出现如下信息则说明挂载成功，即 Linux 服务器已经挂载数据盘：
Filesystem	Size Used Avail Use% Mounted on /dev/vdb	50G 53M 47G 1%	/data 步骤三：实现开机自动挂载 添加数据盘挂载信息至/etc/fstab，实现开机自动挂载。
当您希望云服务器在重启或开机时能自动挂载数据盘，必须将数据盘挂载信息添加到/etc/fstab中。否则云服务器重启或开机后，不会自动挂载数据盘。
使用以下命令添加分区信息：
echo '/dev/vdb /data ext4 defaults 0 0' >> /etc/fstab 使用以下命令查看分区信息：
cat /etc/fstab 出现如下信息则说明添加数据盘挂载信息成功：
/dev/vdb /data ext4 defaults 0 0 自动格式化并挂载数据盘 在腾讯云的 Linux 服务器上，您可以通过运行以下 Shell 脚本来实现自动格式化和挂载数据盘：</description></item><item><title>Mysql5.7主从复制</title><link>https://linkall.pub/blog/mysql-master-slave/index.html</link><pubDate>Tue, 02 Jun 2020 11:09:54 +0000</pubDate><guid>https://linkall.pub/blog/mysql-master-slave/index.html</guid><description>环境 Linux:CentOS7 Mysql:5.7 服务器:腾讯云
安装 见：https://blog.csdn.net/haxyek/article/details/85273553 安装后可能需要的初始化命令：
mysqld --initialize-insecure --user=mysql --explicit_defaults_for_timestamp 主从复制原理 从服务器读取主服务器的binlog，进行数据复制。
主从复制实践 主服务器配置： 第一步：修改my.cnf文件 [mysqld]段增加
#启动而进制日志 log-bin=mysql-bin #服务器唯一ID，一般取IP最后一段 server-id=83第二步：重启mysql服务 systemctl restart mysqld第三步：主机给从机授权备份权限 登录到主机的mysql
myysql> GRANT REPLication slave on *.* to '从机用户名'@'从机ip地址' identified by '从机密码';示例
myysql> GRANT REPLication slave on *.* to 'slave'@'172.32.1.16' identified by 'slave_password';第四步：刷新权限 mysql>flush privileges;第五步：查询master的状态 mysql>show master status; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000002 | 601 | | | | +------------------+----------+--------------+------------------+-------------------+从服务器配置 第一步：修改my.</description></item><item><title>Mysql 数据库名、表名大小写</title><link>https://linkall.pub/blog/mysql-dbname-tablename/index.html</link><pubDate>Tue, 02 Jun 2020 01:44:03 +0000</pubDate><guid>https://linkall.pub/blog/mysql-dbname-tablename/index.html</guid><description>[mysqld] lower-case-table-names=0 ** windows默认为0，unix默认为1； **
变量lower-case-table-names的取值 取值范围有三个，分别是0、1、2.
设置成0：表名按你写的SQL大小写存储，大写就大写小写就小写，比较时大小写敏感。 设置成1：表名转小写后存储到硬盘，比较时大小写不敏感。 设置成2：表名按你写的SQL大小写存储，大写就大写小写就小写，比较时统一转小写比较。 这个选项不仅仅适用于表名的大小写敏感，同样适用于数据库名和表别名。</description></item><item><title>mysql bin-log 误操作数据修复</title><link>https://linkall.pub/blog/mysql-bin-log-reverse/index.html</link><pubDate>Mon, 01 Jun 2020 18:25:23 +0000</pubDate><guid>https://linkall.pub/blog/mysql-bin-log-reverse/index.html</guid><description>先说原理 基于全量备份，加bin-log，将数据恢复到误操作之前节点数据，然后跳过误操作，执行后面操作。使用binlog文件转成sql执行，导入到数据库。
查看binlog文件 如果有多个binlog日志也可以在Mysql命令行下查看当前binlog、切割binlog日志。切割完成binlog再次查看就会看到新的日志写入到新的binlog文件中。
mysql> show master status; +------------------+-----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+-----------+--------------+------------------+-------------------+ | mysql-bin.000001 | 343629748 | | | | +------------------+-----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) mysql> flush logs; Query OK, 0 rows affected (0.01 sec)找到binlog中错误的语句 使用mysqlbinlog命令加参数，可以指定时间段，和pos节点：
--start-position 起始点 --stop-position 结束点（不包含） --start-datetime=“2017--11-01 00:00:00” 起始时间 --stop-datetime="2017-11-11 00:00:00" 终止时间 -d db_name 指定数据库 -v 是显示出一些sql的信息 -vv 则是多一些注释性的东西 --base64-output=DECODE-ROWS 这个是把sql解码出来可以binlog日志中找到错误语句执行的时间点，分别恢复错误语句前后的binlog日志为sql。也可以跳过此步，直接恢复整个binlog日志为sql，然后打开sql文件，删除错误语句。
可以根据时间点来确定误操作的确切时间 mysqlbinlog --no-defaults --database=order --start-datetime='2019-11-02 3:08' --stop-datetime='2019-11-02 23:08' --base64-output=DECODE-ROWS mysql-bin.</description></item><item><title>MySQL初始化基础配置</title><link>https://linkall.pub/blog/mysql-base-config/index.html</link><pubDate>Mon, 01 Jun 2020 05:44:28 +0000</pubDate><guid>https://linkall.pub/blog/mysql-base-config/index.html</guid><description>CentOS7安装Mysql5.7 https://75051685.xyz/archives/centos7-install-mysql
修改编码：/etc/my.cnf
[client] default-character-set = utf8 [mysqld] default-storage-engine = INNODB character-set-server = utf8 collation-server = utf8_general_ci # 不区分大小写 collation-server = utf8_bin # 区分大小写 collation-server = utf8_unicode_ci # 比 utf8_general_ci 更准确 lower_case_table_names=2 # 表名区分大小写 max_connections=1000 # 最大连接数创建数据库和用户 # 创建数据库，编码utf8 CREATE DATABASE &lt;datebasename> CHARACTER SET utf8; # 创建用户，指定用户名，密码，访问主机 CREATE USER 'username'@'host' IDENTIFIED BY 'password'; # 设置权限 GRANT privileges ON databasename.tablename TO 'username'@'host'; # 显示权限 SHOW GRANTS FOR 'username'@'host'; # 回收用户权限 REVOKE privilege ON databasename.</description></item><item><title>一步一步CentOS7 安装 MySQL5.7</title><link>https://linkall.pub/blog/centos7-install-mysql/index.html</link><pubDate>Mon, 01 Jun 2020 01:40:01 +0000</pubDate><guid>https://linkall.pub/blog/centos7-install-mysql/index.html</guid><description>说明： 此文章用于安装Oracle Mysql，而非MariaDB。
yum源处理 对于yum安装，需要知道yum源，参考官网信息即可：
https://dev.mysql.com/downloads/repo/yum/
同时贴出apt源：
https://dev.mysql.com/downloads/repo/apt/
选择下载，本文贴出两个地址一个是5.7，一个是8.0：
# 5.7 https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm # 8.0 最新版本（2018-12-27） https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm 根据两个地址的对比，其他版本链接请自行揣测。下载完后进行安装：
# 安装rpm包 sudo rpm -Uvh mysql57-community-release-el7-11.noarch.rpm # 查看yum yum repolist all | grep mysql # 显示结果 mysql-connectors-community/x86_64 MySQL Connectors Community mysql-tools-community/x86_64 MySQL Tools Community mysql57-community/x86_64 MySQL 5.7 Community Server 安装 sudo yum install mysql-community-server启动 MySQL 服务 Mysql5.7版本默认设置了临时密码，需要在启动之后查看运行日志，里面会有临时密码显示：
sudo cat /var/log/mysqld.log | grep 'temporary password' 修改密码 $ mysql -uroot -p #输入查看到的密码 # 新密码要求符合密码规范。大小写，特殊字符数字等。 mysql> ALTER USER 'root'@'localhost' IDENTIFIED BY '!</description></item><item><title>nginx 80端口重定向到443端口</title><link>https://linkall.pub/blog/nginx-redirect-80-to-443/index.html</link><pubDate>Sun, 31 May 2020 18:34:29 +0000</pubDate><guid>https://linkall.pub/blog/nginx-redirect-80-to-443/index.html</guid><description>使用如下配置即可
server { listen 80; server_name www.test.com; rewrite ^(.*)$ https://${server_name}$1 permanent; }</description></item><item><title>php-fpm 报错500排查</title><link>https://linkall.pub/blog/how-to-debug-php-fpm-500/index.html</link><pubDate>Sun, 31 May 2020 18:33:22 +0000</pubDate><guid>https://linkall.pub/blog/how-to-debug-php-fpm-500/index.html</guid><description>TOC
php-fpm 报错500 php-fpm报错500，使用nginx转发，同时有没有日志。
思路将错误暴露出来：
使用phpinfo将php.ini的路径找出 新建一个页面，内容如下：
&lt;?php phpinfo(); ?> 找到php.ini的位置：
/usr/local/php/etc/php.ini编辑php.ini 查找 display_errors，将配置改为On，即为显示错误。
display_errors = On记得处理好问题后改回去。</description></item><item><title>使用general_log来对Mysql SQL语句监控查看的记录</title><link>https://linkall.pub/blog/mysql-sql-monitor/index.html</link><pubDate>Sun, 31 May 2020 18:27:22 +0000</pubDate><guid>https://linkall.pub/blog/mysql-sql-monitor/index.html</guid><description>查看日志位置：
show global variables like '%general%'; +——————+———-+ |Variable_name|Value| +——————+———-+ |general_log|OFF| |general_log_file|/data0/logs/mysql/general.log| +——————+———-+ 设置 SET GLOBAL general_log = 'ON';
使用tail -f 日志位置 查看即时日志。
临时开启日志记录
set global general_log='ON'; 这时执行的所有sql都会被记录下来，但是如果重启mysql就会停止记录需要重新设置
查看日志
tail -f /data0/logs/mysql/general.log 查看全部
cat /data0/logs/mysql/general.log 查看是否开启binlog
show variables like “log_bin” ; 查看当前的binlog日志
show master status ;</description></item><item><title>CentOS7修改服务器ssh端口号</title><link>https://linkall.pub/blog/centos7-sshd-port/index.html</link><pubDate>Sun, 31 May 2020 18:11:45 +0000</pubDate><guid>https://linkall.pub/blog/centos7-sshd-port/index.html</guid><description>版本 CentOS7
一般情况 编辑sshd的配置文件，增加端口既可
vi /etc/ssh/sshd_config ---- Port 22 Port 1022然后重启服务
systemctl status sshd.service开启了SELinux策略 如果开启了SELinux策略，则可以使用下面命令查看端口状态：
semanage port -l | grep ssh增加访问端口
semanage port -a -t ssh_port_t -p tcp 1022防火墙配置 firewall-cmd --list-all firewall-cmd --zone=public --add-port=1022/tcp --permanent firewall-cmd --reload</description></item><item><title>CentOS7 firewall 开放端口和关闭防火墙</title><link>https://linkall.pub/blog/centos7-firewalld/index.html</link><pubDate>Sun, 31 May 2020 17:30:41 +0000</pubDate><guid>https://linkall.pub/blog/centos7-firewalld/index.html</guid><description>CentOS7开放端口，重载防火墙配置
sudo firewall-cmd --zone=public --add-port=6379/tcp --permanent sudo firewall-cmd --reload检查防火墙规则命令
firewall-cmd --list-all会显示：
public (active) # 状态 target: default icmp-block-inversion: no interfaces: ens33 #接口信息 sources: services: ssh dhcpv6-client #开放服务 ports: 6379/tcp # 开放端口 protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 其他命令：
# 重启防火墙 systemctl restart firewalld # 检查状态 firewall-cmd --state firewall-cmd --list-all #禁用 firewall systemctl disable firewalld systemctl stop firewalld # 查询防火墙状态 systemctl status firewalld #启用防火墙 systemctl enable firewalld systemctl start firewalld # 查询防火墙状态 systemctl status firewalld</description></item><item><title>pinpoint，HBase数据清理</title><link>https://linkall.pub/blog/pinpoint-hbase-data-clean/index.html</link><pubDate>Fri, 29 May 2020 18:29:40 +0000</pubDate><guid>https://linkall.pub/blog/pinpoint-hbase-data-clean/index.html</guid><description>[toc]
HBASE数据清理 pinpoint使用HBASE储存数据，对于HBase进行数据清理。
HBase shell 进入HBASE目录，执行如下命令，进入shell
bin/hbase shell查看表信息 查看HBASE表:
hbase(main):001:0> list TABLE AgentEvent AgentInfo AgentLifeCycle AgentStatV2 ApiMetaData ApplicationIndex ApplicationMapStatisticsCallee_Ver2 ApplicationMapStatisticsCaller_Ver2 ApplicationMapStatisticsSelf_Ver2 ApplicationStatAggre ApplicationTraceIndex HostApplicationMap_Ver2 SqlMetaData_Ver2 StringMetaData TraceV2 15 row(s) in 0.2120 seconds查看表描述 查看表描述，里面有个TTL值，代表数据存储时长
hbase(main):002:0> desc 'AgentInfo' Table AgentInfo is ENABLED AgentInfo COLUMN FAMILIES DESCRIPTION { NAME => 'Info', BLOOMFILTER => 'ROW', VERSIONS => '1', IN_MEMORY => 'false', KEEP_DELETED_CELLS => 'FALSE', DATA_BLOCK_ENCODING => 'PREFIX', TTL => '31536000 SECONDS (365 DAYS)', COMPRESSION => 'NONE', MIN_VERSIONS => '0', BLOCKCACHE => 'true', BLOCKSIZE => '65536', REPLICATION_SCOPE => '0'} 1 row(s) in 0.</description></item><item><title>nginx上传文件413错误</title><link>https://linkall.pub/blog/nginx-413-configuration/index.html</link><pubDate>Thu, 28 May 2020 01:02:50 +0000</pubDate><guid>https://linkall.pub/blog/nginx-413-configuration/index.html</guid><description>nginx报错： 413 Request Entity Too Large 是因为请求体积太大，解决办法：更改Nginx的配置，将客户端上传最大文件体积增大，如下配置，根据自身情况设定。
client_max_body_size 20M;以上配置可放入server、http、location指令中。
全局配置 http{ client_max_body_size 20m; }站点配置 修改站点下location的配置
server { listen 80; server_name 75051685.xyz; location / { root html; index index.html index.htm; } }修改为：
server { listen 80; server_name 75051685.xyz; location / { root html; index index.html index.htm; client_max_body_size 20m; } }</description></item><item><title>使用Docker在内网搭建DNS服务器</title><link>https://linkall.pub/blog/docker-dnsmasq-usage/index.html</link><pubDate>Tue, 26 May 2020 18:22:39 +0000</pubDate><guid>https://linkall.pub/blog/docker-dnsmasq-usage/index.html</guid><description>dnsmasq 搭建web配置界面 使用jpillora提供的docker镜像。
用法 创建一个配置文件/opt/dnsmasq.conf，如下为demo
#dnsmasq config, for a complete example, see: # http://oss.segetech.com/intra/srv/dnsmasq.conf #log all dns queries log-queries #dont use hosts nameservers no-resolv #use cloudflare as default nameservers, prefer 1^4 server=1.0.0.1 server=1.1.1.1 strict-order #serve all .company queries using a specific nameserver server=/company/10.0.0.1 #explicitly define host-ip mappings address=/myhost.company/10.0.0.2启动容器 $ docker run \ --name dnsmasq \ -d \ -p 53:53/udp \ -p 5380:8080 \ -v /opt/dnsmasq.conf:/etc/dnsmasq.conf \ --log-opt "max-size=100m" \ -e "HTTP_USER=foo" \ -e "HTTP_PASS=bar" \ --restart always \ jpillora/dnsmasq其中：	-e "HTTP_USER=foo" -e "HTTP_PASS=bar" 为为dnsmasq设定访问用户名和密码。访问地址：`</description></item><item><title>使用mysqldump导出mysql表结构和表数据</title><link>https://linkall.pub/blog/mysql-dump-usage/index.html</link><pubDate>Mon, 25 May 2020 18:19:28 +0000</pubDate><guid>https://linkall.pub/blog/mysql-dump-usage/index.html</guid><description>创建备份用户 create user dumper@'127.0.0.1' identified by '12345678';赋权限 grant select on *.* to dumper@'127.0.0.1'; grant lock tables on *.* to dumper@'127.0.0.1';备份脚本 #!/bin/bash mkdir /tmp/`date +%y%m%d` mysqldump -h127.0.0.1 -u dumper -p12345678 dbname > /tmp/`date +%y%m%d`/db.sqlcrontab定时任务 凌晨三点执行脚本。
0 3 * * * /opt/software/backup_db.sh >/dev/null 2>&amp;1MySQL 备份包含 emoji 表情的数据 在执行备份命令时，指定字符集即可（@see mysqldump –help）
$ mysqldump -uroot -p123456 --default-character-set=utf8mb4 db_name > db_name_bak.sql常见用法 命令行下具体用法如下：
mysqldump -u用戶名 -p密码 -d 数据库名 表名 > 脚本名;导出整个数据库结构和数据
mysqldump -h localhost -uroot -p123456 database > dump.</description></item><item><title>CentOS7 重置root密码</title><link>https://linkall.pub/blog/centos7-reset-root-password/index.html</link><pubDate>Sun, 24 May 2020 18:15:34 +0000</pubDate><guid>https://linkall.pub/blog/centos7-reset-root-password/index.html</guid><description>1 - 在启动grub菜单，选择编辑选项启动 2 - 按键盘e键，来进入编辑界面 3 - 找到Linux 16的那一行，将ro改为rw init=/sysroot/bin/sh 4 - 现在按下 Control+x，使用单用户模式启动 5 - 现在，可以使用下面的命令访问系统 chroot /sysroot
6 - 重置密码 passwd root
7 - 更新系统信息 touch /.autorelabel
8 - 退出chroot exit
9 - 重启你的系统 reboot</description></item><item><title>如何用Mac线刷小米手机</title><link>https://linkall.pub/blog/mi-phone-fastboot/index.html</link><pubDate>Fri, 22 May 2020 18:26:04 +0000</pubDate><guid>https://linkall.pub/blog/mi-phone-fastboot/index.html</guid><description>目录 TOC
ROM下载地址 对于老款小米，需要使用低版本的ROM才不会卡，这里提供两个ROM历史下载地址，都为非官方的，因为官方的不全。
https://miuiver.com/ https://roms.miuier.com/ mac刷机工具 adb 安装
brew cask install android-platform-tools安装好后配置一下环境变量。 在/etc/profile中加入。
export PATH=~/android-sdks/platform-tools:~/android-sdks/tools:$PATH运行fastboot --version检测是否成功安装并配置好环境。
开始刷机 打开手机调试模式，并手机连接到电脑 进入fastboot模式： 手机已开机使用：adb reboot bootloader 没有开机：开机键+音量下长按 查看当前手机设备名： $ fastboot devices 4e46d6ca	fastboot4e46d6ca为当前设备名 4. 控制台进入到解压后的目录： 运行脚本：
~/Downloads/kenzo_images_V7.5.2.0.LHOCNDE_20160629.0000.25_5.1_cn ⌚ 14:13:59 $ sh flash_all.sh -s 4e46d6catips 实验机器：红米Note3全网通，刷的ROM kenzo_images_V7.5.2.0</description></item><item><title>MySQL查看数据库表容量大小</title><link>https://linkall.pub/blog/mysql-view-database-table-capacity/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linkall.pub/blog/mysql-view-database-table-capacity/index.html</guid><description>1.查看所有数据库容量大小 select table_schema as '数据库', sum(table_rows) as '记录数', sum(truncate(data_length / 1024 / 1024, 2)) as '数据容量(MB)', sum(truncate(index_length / 1024 / 1024, 2)) as '索引容量(MB)' from information_schema.tables group by table_schema order by sum(data_length) desc, sum(index_length) desc;2.查看所有数据库各表容量大小 select table_schema as '数据库', table_name as '表名', table_rows as '记录数', truncate(data_length / 1024 / 1024, 2) as '数据容量(MB)', truncate(index_length / 1024 / 1024, 2) as '索引容量(MB)' from information_schema.tables order by data_length desc, index_length desc; 3.查看指定数据库容量大小 select table_schema as '数据库', sum(table_rows) as '记录数', sum(truncate(data_length / 1024 / 1024, 2)) as '数据容量(MB)', sum(truncate(index_length / 1024 / 1024, 2)) as '索引容量(MB)' from information_schema.</description></item><item><title>线上java程序CPU占用过高问题排查</title><link>https://linkall.pub/blog/troubleshooting-of-high-cpu-consumption-of-online-java-programs/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linkall.pub/blog/troubleshooting-of-high-cpu-consumption-of-online-java-programs/index.html</guid><description>查看系统状况 top 命令查看CPU、内存等使用情况 [root@DEV-L002323 ~]# top top - 14:52:54 up 514 days, 7:00, 8 users, load average: 2.85, 1.35, 1.62 Tasks: 147 total, 1 running, 146 sleeping, 0 stopped, 0 zombie Cpu(s): 57.6%us, 6.3%sy, 0.0%ni, 9.2%id, 26.2%wa, 0.0%hi, 0.0%si, 0.7%st Mem: 3922928k total, 3794232k used, 128696k free, 403112k buffers Swap: 4194296k total, 65388k used, 4128908k free, 1492204k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 6764 root 20 0 2428m 1.</description></item></channel></rss>