<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on 逆天改命</title><link>https://linkall.pub/tags/java/</link><description>Recent content in java on 逆天改命</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 06 Jan 2022 22:52:17 +0000</lastBuildDate><atom:link href="https://linkall.pub/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>jar：解压jar包更改文件后再重新打包</title><link>https://linkall.pub/blog/modify-jar-file/</link><pubDate>Thu, 06 Jan 2022 22:52:17 +0000</pubDate><guid>https://linkall.pub/blog/modify-jar-file/</guid><description>1、阻止jar打包时重新生成清单列表， -M 不生成配置清单，这样还可以使用maven生成的配置清单也就是MANIFEST.MF
jar -cfM xxx.jar * 2、jar打包时不进行压缩 -0
jar -cfM0 xxx * 3、不用解压后替换文件再压缩，如下命令更新更简单：
jar uf xxx.jar BOOT-INF/classes/application-dev.yml 4、解压命令：
jar -xf xxx.jar jar命令参数： jar命令格式：jar {c t x u f }[ v m e 0 M i ][-C 目录]文件名&amp;hellip; 其中{ctxu}这四个参数必须选选其一。[v f m e 0 M i ]是可选参数，文件名也是必须的。
-c　创建新的 JAR 文件包 -t　列出 JAR 文件包的内容列表 -x　展开 JAR 文件包的指定文件或者所有文件 -u　更新已存在的 JAR 文件包 (添加文件到 JAR 文件包中) [vfm0M] 中的选项可以任选，也可以不选，它们是 jar 命令的选项参数 -v　生成详细报告并打印到标准输出 -f　指定 JAR 文件名，通常这个参数是必须的 -m　指定需要包含的 MANIFEST 清单文件 -0　只存储，不压缩，这样产生的 JAR 文件包会比不用该参数产生的体积大，但速度更快 -M　不产生所有项的清单（MANIFEST〕文件，此参数会忽略 -m 参数 [jar-文件] 即需要生成、查看、更新或者解开的 JAR 文件包，它是 -f 参数的附属参数 [manifest-文件] 即 MANIFEST 清单文件，它是 -m 参数的附属参数 [-C 目录] 表示转到指定目录下去执行这个 jar 命令的操作。它相当于先使用 cd 命令转该目录下再执行不带 -C 参数的 jar 命令，它只能在创建和更新 JAR 文件包的时候可用。</description></item><item><title>Java ImageIO 图片处理后变红 解决办法记录</title><link>https://linkall.pub/blog/image-io-write-jpeg/</link><pubDate>Mon, 07 Dec 2020 23:20:07 +0000</pubDate><guid>https://linkall.pub/blog/image-io-write-jpeg/</guid><description>原因：根据网上搜罗的一大堆文章以及自己的发现，是因为原始图片（jpeg）带有alpha通道才会变红，在mac上直接显示简介的看到。 然后发现使用下面这个方式可以解决变红的问题 // 把这行换成下面的方式 BufferedImage image = ImageIO.read(originFile); // 这里是直接根据url读取图片 public static BufferedImage getBufferedImage(String imgUrl) throws MalformedURLException { URL url = new URL(imgUrl); ImageIcon icon = new ImageIcon(url); Image image = icon.getImage(); // 如果是从本地加载，就用这种方式，没亲自测试过 // Image src=Toolkit.getDefaultToolkit().getImage(filePath); // This code ensures that all the pixels in the image are loaded BufferedImage bimage = null; GraphicsEnvironment ge = GraphicsEnvironment .getLocalGraphicsEnvironment(); try { int transparency = Transparency.OPAQUE; GraphicsDevice gs = ge.getDefaultScreenDevice(); GraphicsConfiguration gc = gs.</description></item><item><title>查看Java安装路径</title><link>https://linkall.pub/blog/find-java-install-path/</link><pubDate>Thu, 22 Oct 2020 11:12:55 +0000</pubDate><guid>https://linkall.pub/blog/find-java-install-path/</guid><description>CentOS [root@ai-python ~]# which java /usr/bin/java [root@ai-python ~]# ll -a /usr/bin/java lrwxrwxrwx. 1 root root 22 10月 20 09:35 /usr/bin/java -&amp;gt; /etc/alternatives/java [root@ai-python ~]# ll -a /etc/alternatives/java lrwxrwxrwx. 1 root root 41 10月 20 09:35 /etc/alternatives/java -&amp;gt; /usr/java/jdk1.8.0_191-amd64/jre/bin/java MacOS $ /usr/libexec/java_home -V Matching Java Virtual Machines (3): 1.8.271.09 (x86_64) &amp;#34;Oracle Corporation&amp;#34; - &amp;#34;Java&amp;#34; /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home 1.8.0_271 (x86_64) &amp;#34;Oracle Corporation&amp;#34; - &amp;#34;Java SE 8&amp;#34; /Library/Java/JavaVirtualMachines/jdk1.8.0_271.jdk/Contents/Home 1.8.0_261 (x86_64) &amp;#34;Oracle Corporation&amp;#34; - &amp;#34;Java SE 8&amp;#34; /Library/Java/JavaVirtualMachines/jdk1.</description></item><item><title>@ConditionalOnProperty来控制Configuration是否生效</title><link>https://linkall.pub/blog/conditionalonproperty-base-usage/</link><pubDate>Tue, 11 Aug 2020 09:34:31 +0000</pubDate><guid>https://linkall.pub/blog/conditionalonproperty-base-usage/</guid><description>注解解释 @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.TYPE, ElementType.METHOD }) @Documented @Conditional(OnPropertyCondition.class) public @interface ConditionalOnProperty { String[] value() default {}; //数组，获取对应property名称的值，与name不可同时使用 String prefix() default &amp;#34;&amp;#34;;//property名称的前缀，可有可无 String[] name() default {};//数组，property完整名称或部分名称（可与prefix组合使用，组成完整的property名称），与value不可同时使用 String havingValue() default &amp;#34;&amp;#34;;//可与name组合使用，比较获取到的属性值与havingValue给定的值是否相同，相同才加载配置 boolean matchIfMissing() default false;//缺少该property时是否可以加载。如果为true，没有该property也会正常加载；反之报错 boolean relaxedNames() default true;//是指命名方式 支持驼峰横线方式兼容 } } 使用 @Configuration //在application.properties配置&amp;#34;mf.assert&amp;#34;，对应的值为true @ConditionalOnProperty(prefix=&amp;#34;mf&amp;#34;,name = &amp;#34;assert&amp;#34;, havingValue = &amp;#34;true&amp;#34;) public class AssertConfig { @Autowired private HelloServiceProperties helloServiceProperties; @Bean public HelloService helloService(){ HelloService helloService = new HelloService(); helloService.setMsg(helloServiceProperties.getMsg()); return helloService; } }</description></item><item><title>zuul 自定义负载策略</title><link>https://linkall.pub/blog/zuul-ribbon-irule/</link><pubDate>Mon, 27 Jul 2020 22:21:48 +0000</pubDate><guid>https://linkall.pub/blog/zuul-ribbon-irule/</guid><description>定制IRule 使前后端开发可定制匹配, 学习并配置了网关的负载策略，zuul 底层使用的是 ribbon 的负载组件, ribbon 可以从 eureka 获取服务列表, 所以想要自定义负载, 得从 ribbon 入手, 查看并搜索 loadBalance 相关的类, 可以看到 AbstractLoadBalancerRule 这个类, 查看类树, 可以看到顶级接口为 IRule
/** * 决定最终的服务提供者 */ public Server choose(Object key); /** * 设置负载均衡器 */ public void setLoadBalancer(ILoadBalancer lb); /** * 拿到负载均衡器 */ public ILoadBalancer getLoadBalancer(); debug 分析, 得知 ribbon 默认的负载策略为: ZoneAvoidanceRule, 这个类继承自 AbstractLoadBalancerRule, AbstractLoadBalancerRule中存在 ILoadBalancer 属性, 可以获取负载器, 负载器中又可以获取服务列表等信息
所以我们只需要继承ZoneAvoidanceRule, 重写 choose 方法即可
ribbon 默认的负载器为: DynamicServerListLoadBalancer, 其中包括节点健康状态服务支持, 节点状态的更新(ServerListUpdater), 负载策略, 可用区域的分析, 可以从此类详细了解 ribbon 的运行机制</description></item><item><title>java:too many open files 解决办法</title><link>https://linkall.pub/blog/too-many-open-files/</link><pubDate>Sat, 13 Jun 2020 10:43:22 +0000</pubDate><guid>https://linkall.pub/blog/too-many-open-files/</guid><description>[TOC]
产生原因 Linux 中,文件是一个字节序列。这种简单但强大的定义和它的实现使得系统中的所有东西都可以用文件来表示。这里提示的打开文件过多，不仅仅是普通的文件，也包括通讯链接socket，监听端口。这个错误通常是句柄数超出系统限制。
引起的原因就是进程在某个时刻打开了超过系统限制的文件数量以及通讯链接数。
通过命令ulimit -a可以查看当前系统设置的最大句柄数是多少： $ ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 15065 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 15065 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited open files那一行就代表系统目前允许单个进程打开的最大句柄数，这里是1024。</description></item><item><title>MyBatis获取插入记录的自增长字段值</title><link>https://linkall.pub/blog/mybatis-auto-id/</link><pubDate>Tue, 02 Jun 2020 19:14:57 +0000</pubDate><guid>https://linkall.pub/blog/mybatis-auto-id/</guid><description>MyBatis Plus MyBatis plus 的insert语句，默认会给参数回加上自增主键的值。
MyBatis 再写xml时候注意，需要指定参数类型，parameterType，并加上useGeneratedKeys=&amp;quot;true&amp;quot; 和指定主键字段：keyProperty
&amp;lt;insert id=&amp;#34;insert&amp;#34; parameterType=&amp;#34;com.helloworld.User&amp;#34; &amp;lt;!--指定参数类型--&amp;gt; useGeneratedKeys=&amp;#34;true&amp;#34; keyProperty=&amp;#34;id&amp;#34; &amp;lt;!--指定主键字段--&amp;gt; &amp;gt;</description></item><item><title>线上java程序CPU占用过高问题排查</title><link>https://linkall.pub/blog/troubleshooting-of-high-cpu-consumption-of-online-java-programs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linkall.pub/blog/troubleshooting-of-high-cpu-consumption-of-online-java-programs/</guid><description>查看系统状况 top 命令查看CPU、内存等使用情况 [root@DEV-L002323 ~]# top top - 14:52:54 up 514 days, 7:00, 8 users, load average: 2.85, 1.35, 1.62 Tasks: 147 total, 1 running, 146 sleeping, 0 stopped, 0 zombie Cpu(s): 57.6%us, 6.3%sy, 0.0%ni, 9.2%id, 26.2%wa, 0.0%hi, 0.0%si, 0.7%st Mem: 3922928k total, 3794232k used, 128696k free, 403112k buffers Swap: 4194296k total, 65388k used, 4128908k free, 1492204k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 6764 root 20 0 2428m 1.</description></item></channel></rss>